# 예상 대진표
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12985)

### 사용한 개념
- n이 8일 때, 문제 설명과 같이 대진표를 구성하면 다음과 같다.
```
          1
        /   \
      1       2
     / \     / \
    1   2   3   4
    |\  |\  |\  |\
    1 2 3 4 5 6 7 8
```
- 이 때, n번 선수가 해당 라운드를 이기면 얻게 되는 새로운 번호는 `(n+1)//2`이다.
- 따라서, '해당 라운드를 이기면 얻게 되는 새로운 번호'가 같을 때, 두 선수는 만나서 라운드를 진행한다고 할 수 있다.
- while문을 이용해, '해당 라운드를 이기면 얻게 되는 새로운 번호'가 같아질 때까지 a, b선수의 번호를 2로 나누면 몇 번째 라운드에서 a와 b가 만나는지 알 수 있다.

--- 

# 점프와 순간 이동
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12980)

### 사용한 개념
- dp 문제
    * 이전의 시행이 다음 시행과 연관이 있을 때 dp 방식을 사용한다.
- 문제에서 제시한 두 가지 동작은 다음과 같다.
    * k칸 만큼 점프하여 k의 배터리 소모
    * 배터리 소모 없이 `(현재까지 온 거리) * 2` 에 해당하는 위치로 순간이동
- 즉, 거리 n이 짝수라면 n//2와 배터리 소모 값이 같다.
- 거리 n이 홀수라면 n-1거리에 배터리 1만큼을 더 소모하면 된다.
    * 그런데 n-1거리의 배터리 소모 값은 (n-1)//2와 같다.
- 이를 이용해, n=1 부터 배터리 소모 값을 k[n]으로 나타내면 다음과 같다.
    ```
        k[1] = 1
        k[2] = k[1] = 1
        k[3] = k[2]+1 = k[1]+1 = 2
        k[4] = k[2] = k[1] = 1
        k[5] = k[4]+1 = 2
        k[6] = k[3] = 2
        k[7] = k[6]+1 = 3
        ...
        k[2n] = k[n]
        k[2n+1] = k[2n]+1 = k[n]+1
        ...
    ```
- 이를 이용해, 다음과 같이 k[1]부터 k[n]까지 거리에 따른 배터리 소모 값을 구할 수 있음
    ```python
        k = [0, 1]
        for i in range(2, n+1):
            if i%2 == 0:
                k.append(k[i//2])
            else:
                k.append(k[i//2]+1)
    ```
- 그런데 이 방법은 쓸 데 없는 거리의 배터리 소모 값까지 구하기 때문에 효율적이지 않음
    * n=8일 경우, 3, 5, 6, 7 거리의 값은 필요 없음
    * n=67일 경우, 67, 33, 16, 8, 4, 2, 1의 값만 필요함
- 따라서 n, n//2, (n//2)//2, ((n//2)//2)//2, ..., 1 거리의 값만 구하기 위해 다음과 같이 '필요한 거리'의 리스트를 만듦
    ```python
        index = []
        idx = n
        while idx>=1:
            index.append(idx)
            idx //= 2
        index = index[::-1]
    ```
- 그리고 다음 과정을 통해 각 거리 당 배터리 소모 값을 채워 넣는다.
    ```python
        # 1 부터 순차적으로 채워나감
         # n이 짝수면 k[n] == k[n//2]
        # n이 홀수면 k[n] == k[n//2] + 1
        k = []
        for i in index:
            if i == 1:
                k.append(1)
            elif i%2 == 0:
                k.append(k[-1])
            elif i%2 == 1:
                k.append(k[-1]+1)
    ```
---
여기까지 작성하고 보니, 십진수를 이진수로 수작업으로 변환할 때 방법과 같다는 것을 알았다.
n = 67일 때, 67을 이진수로 변환하는 과정은 다음과 같다.
```
    2_67
    2_33 ... 1
    2_16 ... 1
    2_8 ... 0
    2_4 ... 0
    2_2 ... 0
      1 ... 0
    ==> 67 = 1000011(2)
```
그래서 n을 이진법으로 나타냈을 때 1의 개수와 k는 같을 것으로 예상하고 문제를 풀어보았고 제출했을 때 통과되었다. 이 풀이는 `점프와 순간이동_binary.py` 파일에 저장하였다.

아마도 정석적인 풀이는 dp를 이용하는 것이라고 생각한다.