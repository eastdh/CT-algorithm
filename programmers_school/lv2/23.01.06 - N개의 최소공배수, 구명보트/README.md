# 구명보트
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42885)

### 사용한 개념
- 기본적인 Greedy 알고리즘
    * 각 시행마다 최선의 방법을 사용하는 것이 가장 효율적인 방법일 때 Greedy 알고리즘을 사용한다.
    * 이 문제의 경우 가장 무거운 사람과 가장 가벼운 사람을 태워서 한 번에 최대한 많은 인원(2명)을 구출하는 것이 최선의 방법임
- deque를 import하지 않고 구현하기 위해서 투 포인터 L, R을 활용
    * L의 초기값 = 0
    * R의 초기값 = (사람 수) -1
- people을 역순으로 정렬해 가장 무거운 사람이 왼쪽에 위치하도록 한다.
- while문을 이용해 구현
    * while문의 탈출 조건은 L이 R보다 커졌을 때이다.
    * 가장 무거운 사람 + 가장 가벼운 사람 <= limit일 때 L+1, R-1을 해서 그 둘을 구출
    * 가장 무거운 사람 + 가장 가벼운 사람 > limit일 때 L+1해서 가장 무거운 사람만 구출

--- 

# N개의 최소공배수
[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/12953)

<i>검색해서 푼 문제. [참고한 링크](https://brownbears.tistory.com/454) </i>

### 사용한 개념
- 유클리드 호제법(Euclidean algorithm)
    * 최대공약수를 구하는 공식이다.
    * 두 수 x, y 그리고 x를 y로 나눈 나머지 r에 대하여
    * r != 0 일 때, y를 r로 나눈 나머지 r'를 구한다.
    * r을 r'로 나눈 나머지 r''가 0이라면, x와 y의 최대공약수는 r''이다.
    * 예를 들어, x = 1029, y = 1071일 때 x, y의 최대공약수는 21이다.
    ```
        x%y = r ==> 1029%1071 = 1029
        y%r = r' ==> 1071%1029 = 42
        r%r' = r'' ==> 1029%42 = 21
        r'%r'' = r''' ==> 42%21 = 0   
    ```
    * 이를 파이썬 코드로 나타내면 다음과 같다.
    ```python
        def gcd(x, y): # Greatest Common Divisor
            # y가 0이 될 때까지 반복
            while y != 0:
                # y를 x에 대입
                # x를 y로 나눈 나머지를 y에 대입
                x, y = y, x%y
            return x
    ```
- 두 수x, y의 최소공배수는 두 수를 곱한 값을 최대공약수로 나눈 값과 같다. 
    * 이를 파이썬 코드로 나타내면 다음과 같다.
    ```python
        def lcm(x, y): # Least Common Multiple
            return x * y // gcd(x, y)
    ```

- N개의 숫자에 대해 최소공배수를 구한다면, 
- 두 개의 수에 대해 최소공배수를 구한 다음, 
- 그 값과 아직 계산하지 않은 값 중 하나끼리 최소공배수를 구함. 
- 이를 반복해서, 모든 값을 이용해 최소공배수를 구함.